import { TextToSpeechClient } from '@google-cloud/text-to-speech'
import { Storage } from '@google-cloud/storage'
import path from 'path'
import fs from 'fs/promises'

const ttsClient = new TextToSpeechClient({
  projectId: process.env.GOOGLE_CLOUD_PROJECT_ID,
  keyFilename: process.env.GOOGLE_APPLICATION_CREDENTIALS
})

const storage = new Storage({
  projectId: process.env.GOOGLE_CLOUD_PROJECT_ID,
  keyFilename: process.env.GOOGLE_APPLICATION_CREDENTIALS
})

const BUCKET_NAME = process.env.GCS_BUCKET_NAME || 'slack-link-audio'

export interface AudioResult {
  audioBuffer: Buffer
  fileName: string
  publicUrl?: string
}

export async function generateAudioSummary(
  text: string, 
  title: string,
  maxDurationSeconds: number = 90
): Promise<AudioResult> {
  try {
    // Prepare text for TTS (limit length based on speaking rate)
    const wordsPerMinute = 150 // Average speaking rate
    const maxWords = Math.floor((maxDurationSeconds / 60) * wordsPerMinute)
    const processedText = prepareTextForTTS(text, title, maxWords)

    // Configure TTS request
    const request = {
      input: { text: processedText },
      voice: {
        languageCode: 'en-US',
        name: 'en-US-Neural2-F', // High-quality neural voice
        ssmlGender: 'FEMALE' as const
      },
      audioConfig: {
        audioEncoding: 'MP3' as const,
        speakingRate: 1.0,
        pitch: 0.0,
        volumeGainDb: 0.0,
        effectsProfileId: ['telephony-class-application']
      }
    }

    // Generate audio
    const [response] = await ttsClient.synthesizeSpeech(request)
    
    if (!response.audioContent) {
      throw new Error('No audio content generated')
    }

    const audioBuffer = Buffer.from(response.audioContent as Uint8Array)
    const fileName = `audio_${Date.now()}_${Math.random().toString(36).substring(7)}.mp3`

    return {
      audioBuffer,
      fileName
    }
  } catch (error) {
    console.error('TTS generation failed:', error)
    throw new Error('Failed to generate audio summary')
  }
}

export async function uploadAudioToStorage(
  audioBuffer: Buffer, 
  fileName: string
): Promise<string> {
  try {
    const bucket = storage.bucket(BUCKET_NAME)
    const file = bucket.file(`audio-summaries/${fileName}`)

    await file.save(audioBuffer, {
      metadata: {
        contentType: 'audio/mpeg',
        cacheControl: 'public, max-age=3600'
      }
    })

    // Make file publicly accessible
    await file.makePublic()

    return `https://storage.googleapis.com/${BUCKET_NAME}/audio-summaries/${fileName}`
  } catch (error) {
    console.error('Audio upload failed:', error)
    throw new Error('Failed to upload audio file')
  }
}

function prepareTextForTTS(text: string, title: string, maxWords: number): string {
  // Create introduction
  const intro = `Here's a summary of the article: ${title}.`
  
  // Clean and limit the main text
  let mainText = text
    .replace(/[^\w\s.,!?;:-]/g, '') // Remove special characters that might break TTS
    .replace(/\s+/g, ' ')
    .trim()

  // Split into words and limit
  const words = mainText.split(/\s+/)
  if (words.length > maxWords - 15) { // Reserve words for intro and outro
    mainText = words.slice(0, maxWords - 15).join(' ') + '.'
  }

  // Add conclusion
  const outro = 'This summary was generated by your Slack Link Bot.'

  return `${intro} ${mainText} ${outro}`
}

// Alternative: Save to local file system for development
export async function saveAudioLocally(
  audioBuffer: Buffer, 
  fileName: string
): Promise<string> {
  const publicDir = path.join(process.cwd(), 'public', 'audio')
  
  try {
    await fs.mkdir(publicDir, { recursive: true })
    const filePath = path.join(publicDir, fileName)
    await fs.writeFile(filePath, audioBuffer)
    
    return `/audio/${fileName}`
  } catch (error) {
    console.error('Local audio save failed:', error)
    throw new Error('Failed to save audio file locally')
  }
}